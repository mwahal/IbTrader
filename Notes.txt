

Each account - 
	a unique clientid to connect to TWS
	a unique instance of GW running with a unique TCP port
	a unique account number to be passed


ENTRY Function CancelAllOpenOrder()
	Fill_DB_All_Open_Order()

	for ENTER_DB_OPEN_ORDERS in DB_OPEN_ORDERS
		Cancel_Sym_Order_Update_DB(ENTER_DB_OPEN_ORDERS.localsymbol)
	endfor


ENTRY Function CancelSymOpenOrder(symbol)
	Fill_DB_All_Open_Order()
	if FAILURE then
		LogError(symbol, "Fill_DB_All_Open_Order")
		return
	endif
	ENTER_DB_OPEN_ORDERS = (DB_OPEN_ORDERS.localsymbol == symbol)
	if ENTER_DB_OPEN_ORDERS.localsymbol NOT NULL then
		Cancel_Order_Update_DB(symbol)
	endif

Function Cancel_Sym_Order_Update_DB(symbol)
	ENTRY_OUTSTANDING_ORDERS = (DB_OUTSTANDING_ORDERS.symbol == symbol)
	if ENTRY_OUTSTANDING_ORDERS is not NULL then
		ENTRY_OUTSTANDING_ORDERS.is_order_canceled = TRUE
		PYTHON_cancel_open_order_symbol(symbol)
		if FAILURE then
			LogError(symbol, "OrderCancel")
		endif
	endif



Function: IS_OK_TO_PLACE_ORDER(symbol, trade_only_if_position, wait_for_open_order_to_finish)
		POSITION = Get_Position(symbol)
		if (trade_only_if_position == TRUE)
			if POSITION.qty == 0 then
				return FALSE
			endif
		endif

		ENTRY_OPEN_ORDER = (DB_OUTSTANDING_ORDERS.symbol == symbol)
		if (ENTRY_OPEN_ORDER.open_order == TRUE) then
			if wait_for_open_order_to_finish == TRUE then
				return FALSE
			endif
			do
				ENTRY_OPEN_ORDER = (DB_OUTSTANDING_ORDERS.symbol == symbol)
				if ENTRY_OPEN_ORDER.open_order == TRUE then
					break_loop
				endif
			while TRUE
		endif

				
				

		
ENTRY Function PlaceOrder(symbol, price_signal, secType, currency, qty, action, order_type, limitprice, exchange, order_time)
		
	if IS_OK_TO_PLACE_ORDER(symbol, TRUE, TRUE) returns FALSE then
		return FALSE
	endif
		
	PYTHON_place_asynchronous_order(symbol, price_signal, secType, currency, qty, action, order_type, limitprice, exchange, order_time)

	if FAILURE then
		LogError(FAILURE_CODE, "Order", params[])
		return FALSE
	endif
	verify symbol , qty, action, type 
	Note the order id
	Store it in the database with timestamp
		Table - DB_ORDERS_PLACED
		   ENTRY_ORDERS_PLACED = new Row(DB_ORDERS_PLACED)

		   ENTRY_ORDERS_PLACED.order_open_time = order_time
		   ENTRY_ORDERS_PLACED.price_signal = price_signal

		   ENTRY_ORDERS_PLACED.orderid = orderid
		   ENTRY_ORDERS_PLACED.symbol = symbol
		   ENTRY_ORDERS_PLACED.sectype = sectype
		   ENTRY_ORDERS_PLACED.currency = currency
		   ENTRY_ORDERS_PLACED.exchange = exchange
		   ENTRY_ORDERS_PLACED.qty_requested = qty_requested
		   ENTRY_ORDERS_PLACED.qty_filled = 0
		   ENTRY_ORDERS_PLACED.limit_price = limit_price
		   ENTRY_ORDERS_PLACED.order_action = order_action
		   ENTRY_ORDERS_PLACED.order_type = order_type
		   ENTRY_ORDERS_PLACED.account_number = account_number
		   ENTRY_ORDERS_PLACED.order_completed = FALSE
		   SAVE(DB_ORDERS_PLACED, ENTRY_ORDERS_PLACED)
						

		Table - DB_OUTSTANDING_ORDERS
			ENTRY_OUTSTANDING_ORDERS = new Row(DB_OUTSTANDING_ORDERS)
			ENTRY_OUTSTANDING_ORDERS.symbol = symbol
			ENTRY_OUTSTANDING_ORDERS.is_order_open = TRUE
			ENTRY_OUTSTANDING_ORDERS.is_order_canceled = FALSE
			ENTRY_OUTSTANDING_ORDERS.order_open_time = time()
			ENTRY_OUTSTANDING_ORDERS.orderid = orderid
			SAVE(DB_OUTSTANDING_ORDERS, ENTRY_OUTSTANDING_ORDERS)

Function Fill_DB_All_Open_Order:
	 ### all open orders report from Broker
	openorder_array[] = PYTHON_get_all_open_orders()
	if FAILURE then
		Update_Error_Table(FAILURE_CODE)
		return FALSE
	endif
	all_orderids[] = 0
	for oo in openorder_array[]
		orderid = oo[orderid]
		all_orderids[orderid]++
		SAVE(DB_OPEN_ORDERS, oo)
	endfor
# remove old open entries which are expired now
	for ENTRY_OPEN_ORDERS in DB_OPEN_ORDERS
		oid = ENTRY.orderid
		if all_orderids[orderid] == 0 then
			DELETE(DB_OPEN_ORDERS, ENTRY_OPEN_ORDERS)
		endif
	endfor

Function Fill_DB_All_Execution_Table:

	PYTHON_request_all_executions()
	if FAILURE then
		Update_Error_Table(FAILURE_CODE)
		return FALSE
	endif
	exec_array[] ### all execution reports from Broker 
	entries[] = 0
	for exec in exec_array[]
		oid = exec[orderid]
		entries[oid]++
		SAVE(DB_BROKER_EXEC_REPORT, exec)
	endfor

	for oid in entries
		qty_filled = 0
		last_exectime = 0
		numexec = 0
		for exec in (DB_BROKER_EXEC_REPORT.orderid == oid)
			symbol = exec.symbol
			side = exec.side
			execshares = exec.execshares
			execprice = exec.execprice
			avgprice = exec.avgprice
			qty_filled = MAX(exec.qty_filled, qty_filled)
			last_exectime = MAX(exec.exectime, last_exectime)
			numexec++
		endfor
		ENTRY_GET_ALL_EXECUTIONS = new Row(DB_GET_ALL_EXECUTIONS)
		ENTRY_GET_ALL_EXECUTIONS.orderid = oid
		ENTRY_GET_ALL_EXECUTIONS.symbol = symbol
		ENTRY_GET_ALL_EXECUTIONS.side = side
		ENTRY_GET_ALL_EXECUTIONS.qty_filled = qty_filled
		ENTRY_GET_ALL_EXECUTIONS.numexec = numexec
		ENTRY_GET_ALL_EXECUTIONS.avgprice = avgprice
		ENTRY_GET_ALL_EXECUTIONS.last_exectime = last_exectime
		SAVE(DB_GET_ALL_EXECUTIONS, ENTRY_GET_ALL_EXECUTIONS)
	endfor



	
Function Fill_DB_Execution:

	Fill_DB_All_Execution_Table()
	if FAILURE then
		Update_Error_Table(FAILURE_CODE)
		return FALSE
	endif
	for ENTRY_OUTSTANDING_ORDERS in the table DB_OUTSTANDING_ORDERS
		if ENTRY_OUTSTANDING_ORDERS.is_order_open == TRUE OR  ENTRY_OUTSTANDING_ORDERS.is_order_canceled == TRUE
			ENTRY_ORDERS_PLACED = (DB_ORDERS_PLACED.orderid == ENTRY_OUTSTANDING_ORDERS.orderid)
			orderid = ENTRY_ORDERS_PLACED.orderid
			qty_requested = ENTRY_ORDERS_PLACED.qty_requested
			ENTRY_GET_ALL_EXECUTIONS = (DB_GET_ALL_EXECUTIONS.orderid == orderid)
			qty_filled = ENTRY_GET_ALL_EXECUTIONS.qty_filled
			if (qty_requested == qty_filled) then
				ENTRY_ORDERS_PLACED.order_completed = TRUE
				ENTRY_ORDERS_PLACED.qty_filled = qty_filled
				ENTRY_ORDERS_PLACED.avgprice = ENTRY_GET_ALL_EXECUTIONS.avgprice
				ENTRY_ORDERS_PLACED.order_filled_time = ENTRY_GET_ALL_EXECUTIONS.last_exectime
				ENTRY_ORDERS_PLACED.holding_type = ENTRY_ORDERS_PLACED.order_action == BUY  ? LONG : SHORT
				ENTRY_OUTSTANDING_ORDERS.is_order_open = FALSE
				ENTRY_OUTSTANDING_ORDERS.order_filled_time = ENTRY_ORDERS_PLACED.order_filled_time
				Update_Local_Portfolio(DB_LOCAL_PORTFOLIO, ENTRY_ORDERS_PLACED)
				SAVE(DB_HISTORY_OUTSTANDING_ORDERS, ENTRY_OUTSTANDING_ORDERS)
				DELETE(DB_OUTSTANDING_ORDERS, ENTRY_OUTSTANDING_ORDERS)
			endif
		endif
	endfor
	
	

Function Update_Local_Portfolio(DB_LOCAL_PORTFOLIO, ENTRY_ORDERS_PLACED)
	Index = ENTRY_ORDERS_PLACED.symbol && ENTRY_ORDERS_PLACED.secType && ENTRY_ORDERS_PLACED.currency
	ENTRY_LOCAL_PORTFOLIO = DB_LOCAL_PORTFOLIO(Index)
	If ENTRY_LOCAL_PORTFOLIO is EMPTY then
		SAVE(DB_LOCAL_PORTFOLIO, ENTRY_ORDERS_PLACED)
		return
	endif
	if ENTRY_LOCAL_PORTFOLIO.order_action != ENTRY_ORDERS_PLACED.order_action
		Adjust_Qty_Filled(ENTRY_LOCAL_PORTFOLIO, ENTRY_ORDERS_PLACED)
		if ENTRY_LOCAL_PORTFOLIO.qty_filled == 0 then
			DELETE(DB_LOCAL_PORTFOLIO, ENTRY_LOCAL_PORTFOLIO)
		endif
	endif

Function Fill_DB_Broker_Portfolio
	Portfolio[] = PYTHON_get_all_portfolio()
	if FAILURE then
		Update_Error_Table(FAILURE_CODE)
		return FALSE
	endif
##### FIXME ####
	for all entries in Portfolio

		TABLE_NAME = DB_BROKER_PORTFOLIO
		ENTRY_BROKER_PORTFOLIO = INSERT_REPLACE_IN_TABLE(DB_BROKER_PORTFOLIO, symbol, complete_symbol_type, holding_type, quantity, marketValue, costPrice, gnloss, marketPrice, averageCost, secType, accountName)
		Index = DB_LOCAL_PORTFOLIO.symbol && DB_LOCAL_PORTFOLIO.secType && DB_LOCAL_PORTFOLIO.currency
		ENTRY_LOCAL_PORTFOLIO = DB_LOCAL_PORTFOLIO(Index)
		Compare_Portfolio_BROKER_and_Local(ENTRY_BROKER_PORTFOLIO, ENTRY_LOCAL_PORTFOLIO)
	endfor

Background:
	Fill_DB_All_Open_Order
	Fill_DB_Execution
	Fill_DB_BROKER_Portfolio
