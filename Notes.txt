

Each account - 
	a unique clientid to connect to TWS
	a unique instance of GW running with a unique TCP port
	a unique account number to be passed


Function: IS_OK_TO_PLACE_ORDER(symbol, trade_only_if_position, wait_for_open_order_to_finish)
		POSITION = Get_Position(symbol)
		if (trade_only_if_position == TRUE)
			if POSITION.qty == 0 then
				return FALSE
			endif
		endif

		ENTRY_OPEN_ORDER = (DB_OUTSTANDING_ORDERS.symbol == symbol)
		if (ENTRY_OPEN_ORDER.open_order == TRUE) then
			if wait_for_open_order_to_finish == TRUE then
				return FALSE
			endif
			do
				ENTRY_OPEN_ORDER = (DB_OUTSTANDING_ORDERS.symbol == symbol)
				if ENTRY_OPEN_ORDER.open_order == TRUE then
					break_loop
				endif
			while TRUE
		endif

				
				

		
Function PlaceOrder(symbol, price_signal, secType, currency, qty, action, order_type, limitprice, exchange, order_time)
		
	if IS_OK_TO_PLACE_ORDER(symbol, TRUE, TRUE) returns FALSE then
		return FALSE
	endif
		
	place asynchronous order
		place order
				PlacedOrder 9 Symbol EUR Qty 25000 Limit 0 
				              Action BUY Type MKT  Account DU226708 
							  SecType CASH Exchange IDEALPRO Currency USD
		if failed then
			Update_Error_Table(FAILURE_CODE)
			return FALSE
		endif
		verify symbol , qty, action, type 
		Note the order id
		Store it in the database with timestamp
			Table - DB_ORDERS_PLACED
			   ENTRY_ORDERS_PLACED = new Row()

			   ENTRY_ORDERS_PLACED.order_open_time = order_time
			   ENTRY_ORDERS_PLACED.price_signal = price_signal

			   ENTRY_ORDERS_PLACED.orderid = orderid
			   ENTRY_ORDERS_PLACED.symbol = symbol
			   ENTRY_ORDERS_PLACED.sectype = sectype
			   ENTRY_ORDERS_PLACED.currency = currency
			   ENTRY_ORDERS_PLACED.exchange = exchange
			   ENTRY_ORDERS_PLACED.qty_requested = qty_requested
			   ENTRY_ORDERS_PLACED.qty_filled = 0
			   ENTRY_ORDERS_PLACED.limit_price = limit_price
			   ENTRY_ORDERS_PLACED.order_action = order_action
			   ENTRY_ORDERS_PLACED.order_type = order_type
			   ENTRY_ORDERS_PLACED.account_number = account_number
			   ENTRY_ORDERS_PLACED.order_completed = FALSE
							

			Table - DB_OUTSTANDING_ORDERS
				ENTRY_OUTSTANDING_ORDERS.symbol = symbol
				ENTRY_OUTSTANDING_ORDERS.is_order_open = TRUE
				ENTRY_OUTSTANDING_ORDERS.order_open_time = time()
			    ENTRY_OUTSTANDING_ORDERS.orderid = orderid


Function Fill_All_Execution_Table:

	connect to TWS, Request_All_Executions()
	if failed then
		Update_Error_Table(FAILURE_CODE)
		return FALSE
	endif
	exec_array[] ### all execution reports from Broker 
	entries[] = 0
	for exec in exec_array[]
		oid = exec[orderid]
		entries[oid]++
		STORE(DB_BROKER_EXEC_REPORT, exec)
	endfor

	for oid in entries
		qty_filled = 0
		last_exectime = 0
		numexec = 0
		for exec in (DB_BROKER_EXEC_REPORT.orderid == oid)
			symbol = exec.symbol
			side = exec.side
			execshares = exec.execshares
			execprice = exec.execprice
			avgprice = exec.avgprice
			qty_filled = MAX(exec.qty_filled, qty_filled)
			last_exectime = MAX(exec.exectime, last_exectime)
			numexec++
		endfor
		ENTRY_GET_ALL_EXECUTIONS = new Row(DB_GET_ALL_EXECUTIONS)
		ENTRY_GET_ALL_EXECUTIONS.orderid = oid
		ENTRY_GET_ALL_EXECUTIONS.symbol = symbol
		ENTRY_GET_ALL_EXECUTIONS.side = side
		ENTRY_GET_ALL_EXECUTIONS.qty_filled = qty_filled
		ENTRY_GET_ALL_EXECUTIONS.numexec = numexec
		ENTRY_GET_ALL_EXECUTIONS.avgprice = avgprice
		ENTRY_GET_ALL_EXECUTIONS.last_exectime = last_exectime
		SAVE(DB_GET_ALL_EXECUTIONS, ENTRY_GET_ALL_EXECUTIONS)
	endfor



	
Function Fill_Execution:

	Fill_All_Execution_Table()
	if failed then
		Update_Error_Table(FAILURE_CODE)
		return FALSE
	endif
	for ENTRY_OUTSTANDING_ORDERS in the table DB_OUTSTANDING_ORDERS
		if ENTRY_OUTSTANDING_ORDERS.is_order_open is TRUE
			ENTRY_ORDERS_PLACED = (DB_ORDERS_PLACED.orderid == ENTRY_OUTSTANDING_ORDERS.orderid)
			orderid = ENTRY_ORDERS_PLACED.orderid
			qty_requested = ENTRY_ORDERS_PLACED.qty_requested
			ENTRY_GET_ALL_EXECUTIONS = (DB_GET_ALL_EXECUTIONS.orderid == orderid)
			qty_filled = ENTRY_GET_ALL_EXECUTIONS.qty_filled
			if (qty_requested == qty_filled) then
				ENTRY_ORDERS_PLACED.order_completed = TRUE
				ENTRY_ORDERS_PLACED.qty_filled = qty_filled
				ENTRY_ORDERS_PLACED.avgprice = ENTRY_GET_ALL_EXECUTIONS.avgprice
				ENTRY_ORDERS_PLACED.order_filled_time = ENTRY_GET_ALL_EXECUTIONS.last_exectime
				ENTRY_ORDERS_PLACED.holding_type = ENTRY_ORDERS_PLACED.order_action == BUY  ? LONG : SHORT
				ENTRY_OUTSTANDING_ORDERS.is_order_open = FALSE
				ENTRY_OUTSTANDING_ORDERS.order_filled_time = ENTRY_ORDERS_PLACED.order_filled_time
				Update_Local_Portfolio(DB_LOCAL_PORTFOLIO, ENTRY_ORDERS_PLACED)
				SAVE(DB_HISTORY_OUTSTANDING_ORDERS, ENTRY_OUTSTANDING_ORDERS)
				DELETE(DB_OUTSTANDING_ORDERS, ENTRY_OUTSTANDING_ORDERS)
			endif
		endif
	endfor
	
	

Function Update_Local_Portfolio(DB_LOCAL_PORTFOLIO, ENTRY_ORDERS_PLACED)
	Index = ENTRY_ORDERS_PLACED.symbol && ENTRY_ORDERS_PLACED.secType && ENTRY_ORDERS_PLACED.currency
	ENTRY_LOCAL_PORTFOLIO = DB_LOCAL_PORTFOLIO(Index)
	If ENTRY_LOCAL_PORTFOLIO is EMPTY then
		Create a new row in DB_LOCAL_PORTFOLIO
		Insert(ENTRY_ORDERS_PLACED)
		return
	endif
	if ENTRY_LOCAL_PORTFOLIO.order_action != ENTRY_ORDERS_PLACED.order_action
		Adjust_Qty_Filled(ENTRY_LOCAL_PORTFOLIO, ENTRY_ORDERS_PLACED)
		if ENTRY_LOCAL_PORTFOLIO.qty_filled == 0 then
                    delete ENTRY_LOCAL_PORTFOLIO
		endif
	endif

Function Fill_Broker_Portfolio
	Connect to TWS
	if failed then
		Update_Error_Table(FAILURE_CODE)
		return FALSE
	endif
	Portfolio[] = Get_All_Portfolio()
	for all entries in Portfolio

		TABLE_NAME = DB_BROKER_PORTFOLIO
		ENTRY_BROKER_PORTFOLIO = INSERT_REPLACE_IN_TABLE(DB_BROKER_PORTFOLIO, symbol, complete_symbol_type, holding_type, quantity, marketValue, costPrice, gnloss, marketPrice, averageCost, secType, accountName)
		Index = DB_LOCAL_PORTFOLIO.symbol && DB_LOCAL_PORTFOLIO.secType && DB_LOCAL_PORTFOLIO.currency
		ENTRY_LOCAL_PORTFOLIO = DB_LOCAL_PORTFOLIO(Index)
		Compare_Portfolio_BROKER_and_Local(ENTRY_BROKER_PORTFOLIO, ENTRY_LOCAL_PORTFOLIO)
	endfor

Background:
	Fill_Execution
	Fill_BROKER_Portfolio
